\documentclass[a4paper]{article}
\usepackage[portuges]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancyvrb}
\usepackage{url}

\usepackage{aeguill}  % usefull for pdflatex
%\usepackage[compat2,twosideshift=0mm,left=20mm,right=20mm,bottom=20mm,top=15mm]{geometry}

\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{float}
\usepackage{verbatim}
\usepackage{indentfirst}

\parindent=2em

\title{MDIO}
\author{Gabriel Poça 56974 \and Pedro Nunes 54726 \and Sofia Vieira 54782}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\parskip=0mm
%\tableofcontents
\parskip=2mm


\section{Introdução}
	Este relatório é composto por cinco secções, incluindo esta, sendo que cada uma das seguintes corresponde aos quatro primeiros exercicios em enunciado respectivamente. Por questões de apresentação e simplicidade determinada informação, componente de alguns exercicios, encontra-se em outros documentos, como tal este relatório é acompanhado de um documento denominado \textit{ex2.lp}, onde consta código para o lp\_solve correspondente ao exercicio 2, e outro documento denominado \textit{resumo.pdf} onde consta um documento que contém o resumo para o exercicio 1.

\section{Exercicio 1}
	Como consta na introdução o resumo encontra-se em outro documento denominado \textit{resumo.pdf}. O artigo de base ao resumo tem por titulo "Ants can solve the team orienteering problem" e é da autoria de \textit{Liangjun Ke}, \textit{Claudia Archetti} e \textit{Claudia Archetti}\footnote{http://www.sciencedirect.com/science/article/pii/S360835207002162}. 
	
\section{Exercicio 2}  
	No exercicio 2 deve-se, considerando uma sub-instância do problema original e uma frota de duas viaturas, establecer um modelo de Programação Linear que permita encontrar a solução óptima.
	Consideremos as seguintes variáveis:
	\begin{description}
	\item[\rm $n$] Numero de vértices a visitar, sendo que o vértice $0$ representa o vértice inicial e o vértice $n$ o final.
	\item[$m$] Numero de viaturas.
	\item[$L_{i}$] Prémio em cada vértice para $i = 0,\ldots,n$.
	\item[\rm $Tmax$] Distância máxima que cada viatura pode percorrer.
	\item[$t_{ij}$] Distância entre o vértice $i$ e $j$.
	\item[$x_{ijk}$] Variável binária que representa a passagem, ou não, da viatura $k$ entre o ponto $i$ e $j$.
	\end{description}
	O modelo de Programação Linear é:
	\begin{itemize}
	\item $\sum_{ i=0 }^n\sum_{ j=0 }^n\sum_{ k=0 }^m Lj * x_{ijk}$
	\end{itemize}
	\textit{s.a:} 
	\begin{enumerate}
	\item $\sum_{ i=0 }^{n-1}\sum_{ k=1 }^m x_{ijk} <= 1 				\hfill j=1,\ldots,n$ \\ 
	\item $\sum_{ i=0 }^n x_{ ipk }  = \sum_{ j=0 }^n x_{pjk} 			\hfill p=0,\ldots,n \qquad k=1,\ldots,m$ \\ 
	\item $\sum_{ i=0 }^n\sum_{ j=0 }^n t_{ij} * x_{ijk} <= Tmax 	\hfill k=1,\ldots,m$ \\ 
	\item $\sum_{ i=1 }^{n-1} x_{ 0ik } = 1							\hfill k=1,\ldots,m$ \\ 
	\item $\sum_{ i=1 }^{n-1} x_{ ink } = 1							\hfill k=1,\ldots,m$ \\ 
	\end{enumerate}

	A restrição 1 garante que apenas uma das viaturas pode visitar um ponto. A restrição 2 garante que existe, para cada viatura, um percurso de saida de cada vertice visitado para outro vertice. A restrição em 3 garante que é respeitado um limite máximo de distância percorrida para cada viatura. As restrições em 4 e 5 garantem que uma viatura deve ser 'sair' do vertice inicial e terminar no vértice final. 

	Este relatório é acompanhado de um documento denominado \textit{ex2.lp} onde se encontra o código para o lp\_solve que prova a solução proposta.


\section{Exercicio 3}
O pseudo código na Figura~\ref{caminhoscurtos} consiste num algoritmo que permite encontrar os percursos com maior numero de vértices, sem repetidos, entre dois pontos.

\begin{algorithm}[H]
\floatname{algorithm}{Algoritmo}
\caption{Pseudo código para os caminhos mais curtos.}
\label{caminhoscurtos}
\begin{algorithmic}
	\STATE $nV \gets$ Numero de viaturas.
	\STATE $graph \gets$ Array com todos os vétices a visitar.
	\STATE $dMax \gets$ Valor da distância máxima que cada viatura pode percorrer.
	\STATE $paths :=$ Conjunto que detém os percursos determinados.
	\FOR{$i = 0; i < nV; i \gets i+1$}
		\STATE $path :=$ Novo percurso composto por sequência de vértices vazia.
		\STATE $path \gets path + $ Vértice inicial.
		\WHILE{Procura não terminada}
			\IF{Distância no percurso com distância ao vertice final $< dMax$}
				\STATE $path \gets path + $ Vértice mais próximo do ultimo no percurso.
			\ELSE
				\STATE Remover o ultimo vértice inserido.
				\STATE $path \gets path +$ Vértice final.
			\ENDIF
		\ENDWHILE
		\STATE $paths \gets paths + path$
	\ENDFOR
\end{algorithmic}
\end{algorithm}
Aplicado ao problema em enunciado optemos os seguintes percursos:
\begin{enumerate}
	\item 1 -> 28 -> 18 -> 6 -> 7 -> 3 -> 32
	\item 1 -> 19 -> 20 -> 27 -> 31 -> 22 -> 32
	\item 1 -> 13 -> 9 -> 8 -> 10 -> 11 -> 12 -> 21 -> 32
	\item 1 -> 17 -> 29 -> 32
\end{enumerate}

Deste modo obtemos um \textbf{Lucro Total} de \textbf{150}.

\section{Exercicio 4}

De forma a conseguir melhores resultados que no algoritmo na Figura~\ref{caminhoscurtos} podemos acrescentar outra etapa de processamento. Deste modo depois de determinados os percursos no algoritmo anterior tenta-se substituir os vértices de maior prémio não visitados por visitados, um a um, para todos os percursos, sem nunca ultrapassar o limite de distância máxima para cada percurso e deste modo aumentar o lucro. O pseudo código encontra-se na Figura~\ref{impr} 
\begin{algorithm}[H]                  
\floatname{algorithm}{Algoritmo}
\caption{Pseudo código para o exercício 3.}        
\label{impr}    
\begin{algorithmic}
\STATE $graph =$ Array com todos os vértices. 
\STATE $dMax =$ Valor da distância máxima que cada viatura pode percorrer.
\STATE $paths\gets$ Caminhos mais curtos a partir do algoritmo anterior.
\WHILE{Existir vertices não visitados por analisar}
	\STATE $bestV \gets$ Vértice de maior lucro não visitado.	
	\FOR{$path : paths$ (para todos os percursos)}	
		\FOR{$v : path$ (para todos os vértices do percurso)}	
			\IF{$vb$ melhor que $v$ (no sentido em que apresenta maior lucro)}	
				\STATE Trocar o $v$ por $vb$.	
				\IF{Solução inválida}	
					\STATE Repor $v$.	
				\ELSE
					\STATE Terminar procura e passar ao vértice seguinte.
				\ENDIF	
			\ENDIF	
		\ENDFOR	
	\ENDFOR	
\ENDWHILE
\end{algorithmic}
\end{algorithm}

Podemos considerar que em caso de empate o melhor vértice é escolhido de forma aleatória, tal como o primeiro percurso onde se procura a substituição. Este seria um dos pontos a melhorar. É também de notar que não se especifica um caso de paragem, para tal pode propor-se duas soluções:
\begin{itemize}
	\item O algoritmo itera sobre todos os vértices "livres" terminando quando deixa de se registar alterações nos percursos.
	\item O algoritmo itera sobre todos os vértices livres marcando os visitados e termina após análise de todos.
\end{itemize}
A decição acaba por apenas influenciar o numero de vezes que o ciclo é executado.

Sendo este algortimo moroso realizamos apenas uma primeira iteração: o vértice selecionado foi o 15 e o percurso o 4 sendo a troca realizada com o vértice 29. Deste modo o \textbf{Lucro Total} aumenta de 150 para \textbf{155}. Mais iterações acarrentam melhores resultados.
\appendix
%\section{Código do Programa}

\end{document}
