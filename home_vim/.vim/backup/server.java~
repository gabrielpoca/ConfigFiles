import java.util.TreeMap;
import java.util.*;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
import java.io.*;
import java.net.*;

class User {

	String _name = "default";

	public String getName() {
		return _name;
	}

	public void setName(String name) {
		_name = name;
	}

}


class UserDatabase {

	TreeMap<Integer,User> _users;
	int _index;

	public UserDatabase() {
		_users = new TreeMap<Integer,User>();
		_index = 0;
	}

	public synchronized int newUser() {
		int n_index = _index;
		_index++;
		_users.put(n_index, new User());
		return n_index;
	}

	public synchronized void deleteUser(int i) {
		_users.remove(i);
	}

	public void newUsername(int user, String name) {
		_users.get(user).setName(name);
	}

	public String getUsername(int i) {
		return _users.get(i).getName();
	}

}


class Message {

	String _message = "";
	int _user;

	public Message(String message, int user) {
		_message = message;
		_user = user;
	}

	public String getMessage() {
		return _message;
	}

	public int getUser() {
		return _user;
	}

}


class MessageDatabase {

	ReentrantLock lock = new ReentrantLock();
	Condition newMessage = lock.newCondition();

	TreeMap<Integer, Message> _messages;
	int _index;

	public MessageDatabase() {
		_messages = new TreeMap<Integer, Message>();
		_index = 0;
	}

	public void writeMessage(int user, String message) {
		lock.lock();
		_messages.put(_index, new Message(message, user));
		_index++;
		newMessage.signalAll();
		lock.unlock();
	}

	public Message readMessage(int last_index) {
		lock.lock();
		try {
			while(last_index >= _index)
				newMessage.await();
		} catch (InterruptedException e) {
		}
		Message m = _messages.get(last_index);
		lock.unlock();
		return m;
	}

	public int getIndex() {
		return _index;
	}

}

class Writter extends Thread {

	int _user;
	MessageDatabase _db;
	UserDatabase _users;
	int _index;
	Socket _cs;

	boolean _run = true;

	public Writter (MessageDatabase db, UserDatabase users, int user, Socket cs) {
		_user = user;
		_users = users;
		_db = db;
		_index = db.getIndex();
		_cs = cs;
	}

	public void run() {
		try {
			PrintWriter out = new PrintWriter( _cs.getOutputStream(), true);
			Message current;
			int c_user;
			while(_run) {
				current = _db.readMessage(_index);
				c_user = current.getUser();
				if(c_user != _user) {
					out.print(_users.getUsername(c_user)+" : ");
					out.println(current.getMessage());
				}
				_index++;
			}
			out.close();
		} catch (IOException e) {
		}
	}

	public void end() {
		_run = false;
	}

}



class Reader extends Thread {

	int _user;
	MessageDatabase _db;
	UserDatabase _users;
	int _index;
	Socket _cs;

	boolean _run = true;

	public Reader (MessageDatabase db, UserDatabase users, int user, Socket cs) {
		_user = user;
		_users = users;
		_db = db;
		_index = db.getIndex();
		_cs = cs;
	}

	public void run() {
		try {
			Writter w = new Writter(_db, _users, _user, _cs);
			Thread t = new Thread(w);
			t.start();
			BufferedReader in = new BufferedReader( new InputStreamReader(_cs.getInputStream()));
			String current;
			while((current = in.readLine()) != null) {
				if(current.startsWith("/NICK ")) {
					String name = current.replaceFirst("/NICK ", "");
					_users.newUsername(_user, name);
				}
				else if(current.startsWith("/EXIT")) {
					break;
				}
				else {
					_db.writeMessage(_user, current);
				}
			}
			in.close();
			_cs.close();
			w.end();
			t.join();
		} catch (IOException e) {
		} catch (InterruptedException e) {
		}
	}
}


class SERVER {

	final static int MAX_CONN = 10;

	public static void main(String[] argv) {

		try {
			UserDatabase users = new UserDatabase();
			MessageDatabase messages = new MessageDatabase();

			ServerSocket ss = new ServerSocket(9999);
			Thread[] t = new Thread[MAX_CONN];

			System.out.println("Server starting!");

			for(int i = 0; i < MAX_CONN; i++) {
				Socket cs = null;
				cs = ss.accept();
				System.out.println("Connection "+i+" accepted!");
				t[i] = new Thread(new Reader(messages, users, users.newUser(), cs));
				t[i].start();
			}

			for(int i = 0; i < MAX_CONN; i++) 
				t[i].join();

			ss.close();

		} catch( IOException e) {
		} catch( InterruptedException e) {
		}
	}

}
